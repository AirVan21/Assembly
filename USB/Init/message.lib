messageLib macro

; =====================================================================================================
; Temporary BAR information


qTDOffset   = 20h 
qBuffOffset = 00008000h

PeriodicFramInMem = 01000000h 

QHInMemSA  =  000A0000h
qTDfirst   =  000A0100h
qTDBufferR =  00090000h
qTDBufferW =  00080000h


; АДРЕСА СТРУКТУР ДАННЫХ USB
; НЕлинейный адрес очереди
Addr_QH           DD ?
; Нелинейный адрес массива дескрипторов передачи
Addr_TD_Array     DD ?

; Линейный адрес дескриптора команды
Addr_CommandDescr DD ?
; Линейный адрес буфера данных
Addr_DataDescr    DD ?
; Максимальный размер передаваемых данных у устройства
db	0
Max_Data_Size	DB  8
db	0
iMan	db 0;
iProd	db 0;
iSerial	db 0;

EHCItop		dw EHCIbases
EHCIbases	dd 20 dup(0) ; сохраним базы EHCI
; ПАРАМЕТРЫ ТРАНЗАКЦИЙ
; Номер кадра в момент начала транзакции
StartFrame    DW ?
; Состояние триггера данных
DataTrigger   DD ?
; Объем данных в передаваемом массиве
BULK_DataSize DW 0

; ДЕСКРИПТОРЫ КОМАНД
; Дескриптор команды "Get Device Descriptor"
GetDevDesc   DB 80h,6
             DW 100h,0,8
; Дескриптор команды "Get Device Descriptor" 18 байт
GetDevDesc18 DB 80h,6
             DW 100h,0,18
; Дескриптор строки
GetStrDesc64   DB 80h,6
             DW 300h,0409h,64
;                __ - здесь нуже индекс строки     
; запрос английского языка
; Создать дескриптор команды "Set Address"
SetAddrDesc  DB 0,5
             DW 1,0,0
; Дескриптор команды "Get Configuration Descriptor"
GetConfDesc  DB 80h,6
             DW 200h,0,8
;
FrameListBaseAddr dw 0 	;FrameListBase
FrameListBase db 9*1024 dup(0)

; БУФЕР ДАННЫХ
DataBuffer DB 4096 DUP(0) 


	; Extra function Processing start 
	; 
	; EBX - contains Base Address 
	introInMessaging:
		
		push eax				; Save Registers 
		push ebx
		push edx 
		push edi 
		push ecx 

		mov edi, ebx            ; Save Base Address
		
		
		call InitializeQueueSpace
		
		call constructQueueHeadSA

		;call createMessageSequence

		call updateAsynchQueue	; 

		call printUploadBuffer

		;call printNewLineRM

		mov ebx, edi 			; 

		;call runAQueueinCMD

		pop ecx 
		pop edi
		pop edx 
		pop ebx
		pop eax 

		db 0C3h                			; ret  


	; Setup Control Traffiic
	;
	createMessageSequence:

		;===============================
		; Constructing a Queue Head 

		push eax                        ; Saves eax
		push ebx                        ; 
		push edx                        ; Will be used as a mem pointer


		;===============================
		; Constructing Setup qTD
		
		xor ebx, ebx 
		
		; Next qTD pointer (0x00)
		mov eax, dword ptr[Addr_TD_Array]; Address of first qTD 
		mov edx, eax                     ; 
		add edx, qTDOffset               ; Points to the next qTD 
		mov bx, ds  					 ;
		shl ebx, 4                       ;
		add ebx, edx                     ;
		mov [eax], ebx                   ; Puts pointer in qTD 

		; Alternative qTD (0x04) 
		add eax, 4                       ; Next field
		mov edx, 01h 				     ; Set Alternative qTD Invalid 
		mov [eax], edx                   ; Alternative qTD = 0h 

		; qTD token (0x08)                   
		add eax, 4                        ; 
		mov edx, 00080E80h                ; 8 byte Payload [30:16] | Setup PID | Active bit 
		mov [eax], edx                    ; 

		; qTD Buffer Pointer list
		; 4Kbyte (5000h) aligned (0x0C)
		add eax, 4                         ;
		mov edx, dword ptr [Addr_DataDescr]; Payload Pointer 
		mov fs:[eax], edx                  ; 

		; Write Payload (8 byte)
		mov edx, qTDBufferR               ;
		xor ebx, ebx                      ;
		mov bl, 80h                       ; bmRequestType
		mov fs:[edx], bl                  ; 
		mov bl, 00h                       ; bRequest
		mov fs:[edx+1], bl                ; 
		add edx, 2 						  ; 

		xor bx, bx                      ; Zero 

		mov fs:[edx], bx                ; wValue
		mov fs:[edx+2], bx              ; wIndex
		mov bx, 02h                     ; wLength
		mov fs:[edx+4], bx              ;  

		xor ebx, ebx 					; Zero Extra Buffer Pointers
		; (0x10)
		add eax, 4
		mov fs:[eax], ebx 
		; (0x14)
		add eax, 4
		mov fs:[eax], ebx 
		; (0x18)
		add eax, 4
		mov fs:[eax], ebx 
		; (0x1C)
		add eax, 4
		mov fs:[eax], ebx 

		;===============================
		; Constructing IN qTD

		mov eax, qTDfirst
		mov edx, qTDOffset
		add eax, edx					; Points to IN qTD

		mov edx, eax 					; Save IN Address in edx 

		; (0x00)
		add edx, qTDOffset				; qTD after IN 
		mov fs:[eax], edx				; Next qTD pointer
		
		; (0x04)
		add eax, 04h 					;
		mov ebx, 01h 					; Invalid Alternative Pointer
		mov fs:[eax], ebx 				; ZERO field 
		
		; (0x08)
		add eax, 04h 					;
		mov ebx, 80020D80h 				; [31] = 1 In Packet; [14:12] = 000b; [9:8] = 01b IN PID; [7:0] = 0x80 Ready Status 
		mov fs:[eax], ebx				; [30:16] = bytes to transfer 
		
		; (0x0C)
		add eax, 04h 					;
		mov ebx, qTDBufferW				; Address of Buffer to Write
		mov fs:[eax], ebx 				; 

		xor ebx, ebx 					; Zero Extra Buffer Pointers
		; (0x10)
		add eax, 4
		mov fs:[eax], ebx 
		; (0x14)
		add eax, 4
		mov fs:[eax], ebx 
		; (0x18)
		add eax, 4
		mov fs:[eax], ebx 
		; (0x1C)
		add eax, 4
		mov fs:[eax], ebx 

		;===============================
		; Constructing OUT qTD

		mov eax, qTDfirst				;  
		mov edx, qTDOffset				;
		add eax, edx                    ;
		add eax, edx                    ; Points to OUT qTD
		mov ebx, 0DEAD0001h				; Last Packet 
		mov fs:[eax], ebx 				; Last Packet

		mov ebx, 01h 					; Invalid Alternative Link 
		add eax, 04h 					; 
		mov fs:[eax], ebx 				; 

		add eax, 04h 					; 
		mov ebx, 80008C80h				; [30:16] - Zero Length, [9:8] OUT PID 
		mov fs:[eax], ebx 				; Write OUT packet 

		xor ebx, ebx 					; Empty Buffer Pointer 
		add eax, 04h 					;
		mov fs:[eax], ebx 				;

		xor ebx, ebx 					; Zero Extra Buffer Pointers
		; (0x10)
		add eax, 4
		mov fs:[eax], ebx 
		; (0x14)
		add eax, 4
		mov fs:[eax], ebx 
		; (0x18)
		add eax, 4
		mov fs:[eax], ebx 
		; (0x1C)
		add eax, 4
		mov fs:[eax], ebx  

		pop edx
		pop ebx
		pop eax 
		
		db 0C3h                			; ret 

	
	; Constructing a Queue Head 
	; 
	constructQueueHeadSA proc near
		
		push eax                        ; Saves eax
		push ebx                        ; 
		push edx                        ;
		push cx                         ; 
		;-------------------------------;

		xor edx, edx                    ;
		
		; QH Horizontal Link Pointer (0x00)
		mov eax, dword ptr [Addr_QH]    ; Pointer to the Queue
		mov dx, ds                      ; Data Segment
		shl edx, 4 						; Linear Address
		add eax, edx                    ; 
		mov ebx, eax				    ;
		or ebx, 03h						; Marks this as "Invalid QH pointer"
		mov eax, dword ptr [Addr_QH]    ;
		mov [eax], ebx        		    ; 2-nd bit shows that this is QH

		; Endpoint characteristics (0x04)
		add eax, 4                      ;
		mov ebx, 0040D000h				;
		mov [eax], ebx    		        ; (0x400 - max packet size [26:16])

		; Transaction information (0x08)
		add eax, 4 
		mov ebx, 40000000h              ; Check! 
		mov [eax], ebx 		            ; One transaction per microframe

		; Current qTD (0x0C)
		add eax, 4                      ; Set as Zero 
		xor ebx, ebx 					; 
		mov [eax], ebx                  ;

		; Next qTD (0x10)
		add eax, 4 
		mov ebx, Addr_TD_Array          ; Pointer to first qTD to process                        
		xor edx, edx                    ;
		mov dx, ds                      ;
		shl edx, 4                      ; Linear Address
		add edx, ebx                    ;
		mov fs:[eax], edx               ;

		; Alternative qTD Pointer (0x14)
		add eax, 4 
		mov ebx, 01h 					; Mark as Invalid 
		mov [eax], ebx                  ; Input invalid  

		;-------------------------------;	
		pop cx                          ;
		pop edx 						;
		pop ebx 						; 
		pop eax  					    ; 
		
		db 0C3h                			; ret 

	endp 	

	; Sets USBCMD (Run/Stop) zero-bit to ZERO  
	; Wait for 16 microframes   
	; 
	; EBX - contains Base Address 
	stopHCinCMD proc

		push edx						; Save Register
		push ebx 						; 
		push cx                         ;

		xor edx, edx                    

		mov dx, OperRegOff				; Offset for Operational Register
		add ebx, edx                    ; USBCMD Base Address 

		mov edx, fs:[ebx]               ; Gets USBCMD Register 
		and edx, 0fffffffeh             ; Clears Run/Stop bit 
		mov fs:[ebx], edx               ; Set updated value 

										; Wait till apply 
		mov cx, 040h 					; 64 iterations
	
	wait16Microframes:
		loop wait16Microframes

		pop cx  						; Recover Register 
		pop ebx 						;
		pop edx 						; 

		ret 
	
	endp 


	; Sets USBCMD (Run/Stop) zero-bit to ONE  
	; Software shouldn't write USBCMD (Run/Stop) until USBSTS (HCHalted) bit is one    
	; 
	runHCinCMD proc

		push edx						; Save Register
		push ebx 						; 
		push cx							;
		
		mov ebx, HCBaseAddress          ;

		xor edx, edx                    

		mov dx, OperRegOff				; Offset for Operational Register
		add ebx, edx                    ; USBCMD Address

		
		mov edx, fs:[ebx]               ; Gets USBCMD Register 
		or edx, 1h             			; Sets to one Run/Stop bit 
		mov fs:[ebx], edx               ; Set updated value 

		add ebx, USBSTSoffset			; USB STS Address 

		; Under Question! (USB STS BLOCKING FACTOR)

	  waitHCHaltedBit:               
		mov eax, fs:[ebx]				; Get USBSTS value 
		test eax, 00001000h             ; Checking 12-th bit 
		jnz waitHCHaltedBit             ; Wait Until HCHalted is Set   

		pop cx 							;
		pop ebx 						; Recover Register 
		pop edx 						; 

		ret 
	
	endp

	; Sets USBCMD (Asynch Queue) bit to ZERO  
	; 
	; EBX - contains Base Address 
	stopAQueueinCMD proc

		push edx						; Save Register
		push ebx 						; 

		xor edx, edx                    

		mov dx, OperRegOff				; Offset for Operational Register
		add ebx, edx                    ; USBCMD Base Address 

		mov edx, fs:[ebx]               ; Gets USBCMD Register 
		and edx, 0ffffffdfh             ; Clears Asynch Queue bit 
		mov fs:[ebx], edx               ; Set updated value 

										; Recover Register 
		pop ebx 						;
		pop edx 						; 

		ret 
	
	endp

	; Sets USBCMD (Asynch Queue) bit to ONE 
	; 
	runAQueueinCMD proc

		push edx						; Save Register
		push ebx 						; 

		mov ebx, HCBaseAddress 		    ; Gets Base Address

		xor edx, edx                    

		mov dx, OperRegOff				; Offset for Operational Register
		add ebx, edx                    ; USBCMD Base Address 

		mov edx, fs:[ebx]               ; Gets USBCMD Register 
		or edx, 20h   			        ; Clears Asynch Queue bit 
		mov fs:[ebx], edx               ; Set updated value 

										; Recover Register 
		pop ebx 						;
		pop edx 						; 

		ret 
	
	endp 	 	 

	; Sets AsуnchLBRegister on Already Created Queue Structure
	; 
	updateAsynchQueue:

		push eax                        ; Saves eax
		push ebx                        ; 
		push edx						;    

		xor edx, edx 					;

		mov ebx, HCBaseAddress			; Gets Base Address Offset

		mov dx, OperRegOff				; Offset for Operational Register
		add dx, AsуnchLBoffset			;
		add ebx, edx					; Points in AsуnchLBReg 

		
		xor eax, eax 

		mov edx, dword ptr [Addr_QH]    ;
		mov ax, ds                      ; Data Segment
		shl eax, 4                      ; 

		add eax, edx 
		
		mov fs:[ebx], eax 				; Point on own Queue 

		pop edx 
		pop ebx                         ; Recover 
		pop eax 

		db 0C3h                			; ret 



	; Prints Data From Simple Buffer
	; 
	printUploadBuffer:

		push eax                        ; Saves eax
		push ebx                        ; 
		push edx   

		
		mov ebx, dword ptr [Addr_DataDescr]
 
 		push bx
		shr ebx, 16
		push bx 

		call printWordFromStackRM
		call printWordFromStackRM 

		call printNewLineRM

		mov edx, 5555h
		mov [Addr_DataDescr], edx
		

		mov ebx, [Addr_DataDescr]  ; Gets DWORD from Buffer 

		push bx
		shr ebx, 16
		push bx 

		call printWordFromStackRM
		call printWordFromStackRM 
		
		pop edx 
		pop ebx                         ; Recover 
		pop eax 

		db 0C3h                			; ret 

	; Prints Data From Simple Buffer
	; 
	clearUploadBuffer:

		push eax                        ; Saves eax
		push ebx                        ; 
		
		xor ebx, ebx 

		mov eax, qTDBufferW				;
		mov fs:[eax], ebx				;  

		pop ebx                         ; Recover 
		pop eax 

		db 0C3h                			; ret 

	; Init Space for Queue Structures  
	; 
	InitializeQueueSpace:
		
        pushad

		;-----------------------;
        ; Вычислить линейный адрес сегмента дескрипторов
        xor     eax, eax 
        mov     ax, ds
        shl     eax, 4
        mov     edx, eax    ;запомнить адрес сегмента
        xor     eax, eax
        xor     ebx, ebx 
        mov     bx, offset FrameListBase ; Адрес
	    add	    ebx, edx
	    and	    ebx, 0FFFFF000h
	    add	    ebx, 1000h		; выровняли на границу 4 килобайт
	    sub	    ebx, edx
        mov     FrameListBaseAddr, bx	; адрес не линейный (выровненный на гранцу 4К)
        
        ; Вычислить линейный адрес буфера данных
        xor     eax, eax 
        xor     ebx, ebx
        lea     bx, DataBuffer
        ; В edx адрес сегмента
        add     ebx, edx
        and	    ebx, 0FFFFF000h
	    add	    ebx, 1000h		; выровняли на границу 4 килобайт
        mov     [Addr_DataDescr], ebx	; адрес линейный
        
        ; Вычислить линейный адрес заголовка списка выровняв его по границе 16 байт
	    ; теперь дескриптор будет выровнен по этой границе, но его нужно заново заполнить
	    xor	ebx,ebx
	    mov bx, FrameListBaseAddr
	    add	ebx, 4096
        mov [Addr_QH], ebx		; адрес не линейный Начала Очереди
	    
	   
	   ; Вычислить указатель на массив дескрипторов
       
	   mov	eax, ebx
	   add	eax, 30h
	   and	eax, 0FFFFFFF0h

	   mov [Addr_TD_Array], eax  ; запись нелинейного адреса
         
       popad
        
	   db 0C3h                	; ret 

endm