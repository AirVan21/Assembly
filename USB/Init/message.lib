messageLib macro

; =====================================================================================================
; Temporary BAR information

BAR1 = 0C360A000h
BAR2 = 0C3609000h


qTDOffset   = 40h 
qBuffOffset = 00008000h

QHInMem    =  00A00000h
qTDfirst   =  00A00100h
qTDBuffer  =  00900000h

	; Extra function Processing start 
	; 
	; EBX - contains Base Address 
	introInMessaging proc 
		
		push eax				; Save Registers 
		push ebx
		push edx 
		push edi 
		
		mov edi, ebx            ; Save Base Address
		xor edx, edx            ; 

		
		; USB CMD
		lea dx, USBCMDmsg       ; Address for Message
		mov ah, 09h             ; Print Function
		int 21h

		mov eax, USBCMDoffset   ; USBCMD 

		call retrieveOperRegister; Prints USB CMD Register 

		call printNewLineRM     ; Prints New Line 

		; USB STS 
		lea dx, USBSTSmsg       ; Address for Message
		mov ah, 09h             ; Print Function
		int 21h

		mov ebx, edi            ; Base Address 
		mov eax, USBSTSoffset   ; USBSTS 

		call retrieveOperRegister ; Print USB STS

		call printNewLineRM     ; Prints New Line 
		call printNewLineRM     ; Prints New Line
		
		call stopHCinCMD        ; Clear Run/Stop bit in USBCMD 

		; USB CMD
		mov ebx, edi            ; Base Address 
		
		lea dx, USBCMDmsg       ; Address for Message
		mov ah, 09h             ; Print Function
		int 21h

		mov eax, USBCMDoffset   ; USBCMD 

		call retrieveOperRegister; Prints USB CMD Register 

		call printNewLineRM     ; Prints New Line

		; USB STS 
		lea dx, USBSTSmsg       ; Address for Message
		mov ah, 09h             ; Print Function
		int 21h

		mov ebx, edi            ; Base Address 
		mov eax, USBSTSoffset   ; USBSTS 

		call retrieveOperRegister ; Print USB STS

		call printNewLineRM     ; Prints New Line
		call printNewLineRM     ; Prints New Line

		mov ebx, edi            ; Base Address 

		call runHCinCMD        ; Clear Run/Stop bit in USBCMD 

		; USB CMD
		mov ebx, edi            ; Base Address 
		
		lea dx, USBCMDmsg       ; Address for Message
		mov ah, 09h             ; Print Function
		int 21h

		mov eax, USBCMDoffset   ; USBCMD 

		call retrieveOperRegister; Prints USB CMD Register 

		call printNewLineRM     ; Prints New Line

		; USB STS 
		lea dx, USBSTSmsg       ; Address for Message
		mov ah, 09h             ; Print Function
		int 21h

		mov ebx, edi            ; Base Address 
		mov eax, USBSTSoffset   ; USBSTS 

		call retrieveOperRegister ; Print USB STS

		call printNewLineRM     ; Prints New Line
		
		;call printNewLineRM

		;mov eax, 00080010h      ; Default USBCMD value (with enables ASYNCH Queue)
		
		;mov fs:[ebx], eax       ;             

		;mov ebx, fs:[ebx]       ; 
		
		;push bx
		;shr ebx, 16
		;push bx
		;call printWordFromStackRM
		;call printWordFromStackRM 
		
		;mov edi, ebx            ; 
		
		;mov fs:[ebx], edx       ;             

		;call createMessageSequence
		
		;call initListBase 
		
		
		; Configuration information 

		;mov ebx, BAR1           ; 
		;mov eax, USBSTSoffset   ; USBCMD 
		;call retrieveOperRegister
	
		pop edi
		pop edx 
		pop ebx
		pop eax 

		ret

	endp     


	; Setup Queue Head Handle a Control Traffiic
	;
	; DS - data segment   pointer
	; ES - screen segment pointer
	; DI 	- offset for printing string in Video Mem
	createMessageSequence:

		;===============================
		; Constructing a Queue Head 

		push eax                        ; Saves eax
		push ebx                        ; 
		push edx                        ; Will be used as a mem pointer

		; QH Horizontal Link Pointer
		mov eax, QHInMem                ; Pointer to the next Queue, which should be processed
		mov fs:[eax], 00A00002h         ; 2-nd bit shows that this is QH

		; Endpoint characteristics 
		add eax, 4                      ;
		mov fs:[eax], 0040D000h         ; 40 - max packet size; Low Speed Device Indication

		; Transaction information
		add eax, 4 
		mov fs:[eax], 40000000h         ; One transaction per microframe

		; Current qTD
		add eax, 4                      ; Set as Zerp
		xor ebx, ebx 
		mov fs:[eax], ebx               ;

		; Next qTD
		add eax, 4 
		mov ebx, qTDfirst               ; Pointer to first qTD to process                        
		mov fs:[eax], ebx               ;

		;===============================
		; Constructing qTD
		
		; Next qTD pointer 
		mov eax, qTDfirst               ; Address of first qTD 
		mov edx, eax                    ; 
		add edx, qTDOffset              ; Points to the next qTD 
		mov fs:[eax], edx               ; Puts pointer in qTD 

		; Alternative qTD  
		mov edx, eax                    ;
		add edx, 4                      ; Next field
		xor eax, eax                    ;
		mov fs:[edx], eax               ; Alternative qTD = 0h 

		; qTD token                    
		add edx, 4                      ; 
		mov eax, 00080E80h              ; Setting Setup PID | 8 byte Payload
		mov fs:[edx], eax               ; 

		; qTD Buffer Pointer list
		; 4Kbyte aligned 
		add edx, 4                      ;
		mov eax, qTDBuffer              ; Payload Pointer 
		mov fs:[edx], eax               ; 

		; Write Payload (8 byte)
		mov eax, qTDBuffer              ;
		mov ebx, 80060001h              ; GET_DESCRIPTOR (Device)
		mov fs:[eax], ebx               ;
		add eax, 4                      ;
		mov ebx, 00004000h              ; Length of Descriptor 
		mov fs:[eax], ebx               ;

		;===============================
		; 
		
		pop edx
		pop ebx
		pop eax 
		
		ret           

	; Sets USBCMD (Run/Stop) zero-bit to ZERO  
	; Wait for 16 microframes   
	; 
	; EBX - contains Base Address 
	stopHCinCMD proc

		push edx						; Save Register
		push ebx 						; 
		push cx                         ;

		xor edx, edx                    

		mov dx, OperRegOff				; Offset for Operational Register
		add ebx, edx                    ; USBCMD Base Address 

		mov edx, fs:[ebx]               ; Gets USBCMD Register 
		and edx, 0fffffffeh             ; Clears Run/Stop bit 
		mov fs:[ebx], edx               ; Set updated value 

										; Wait till apply 
		mov cx, 040h 					; 64 iterations
	wait16Microframes:
		loop wait16Microframes

		pop cx  						; Recover Register 
		pop ebx 						;
		pop edx 						; 

		ret 
	
	endp 

	; Sets USBCMD (Run/Stop) zero-bit to ONE  
	; Software shouldn't write USBCMD (Run/Stop) until USBSTS (HCHalted) bit is one    
	; 
	; EBX - contains Base Address 
	runHCinCMD proc

		push edx						; Save Register
		push ebx 						; 
		push cx							;
		xor edx, edx                    

		mov dx, OperRegOff				; Offset for Operational Register
		add ebx, edx                    ; USBCMD Address

		
		mov edx, fs:[ebx]               ; Gets USBCMD Register 
		or edx, 1h             			; Sets to one Run/Stop bit 
		mov fs:[ebx], edx               ; Set updated value 

		add ebx, USBSTSoffset			; USB STS Address 

		; Under Question! (USB STS BLOCKING FACTOR)

	  waitHCHaltedBit:               
		mov eax, fs:[ebx]				; Get USBSTS value 
		test eax, 00001000h             ; Checking 12-th bit 
		jnz waitHCHaltedBit             ; Wait Until HCHalted is Set   

		pop cx 							;
		pop ebx 						; Recover Register 
		pop edx 						; 

		ret 
	
	endp 


	; Init Periodic List Base
	;	
	initListBase:

		push eax                        ; Saves eax
		push ebx                        ; 
		push edx   

		mov edx, BAR1                   ;
		add edx, 20h                   	;
		mov fs:[edx], 00080010h         ; Default USB CMD value (with AsyncSchedule)

		add edx, PeriodLBoffset         ; 
		mov eax, QHInMem                ;
		mov fs:[edx], eax               ; Set ListBase Register to QH 

		mov edx, BAR1            		;
		add edx, 20h                   	;
		mov fs:[edx], 00080011h         ; Default USB CMD value (with AsyncSchedule)

		pop edx 
		pop ebx                         ; Recover 
		pop eax 

		ret                             ; 

endm