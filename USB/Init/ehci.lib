initEHCI macro
	
; =====================================================================================================
; Variables

EECPvalue			dw 0h 	

OperRegOff 			dw 20h
HCPCIAddress 		dd 0h
HCBaseAddress 		dd 0h 
USBLEGSUPReg		dd 0h
USBLEGCTLSTSReg 	dd 0h

; Paragraph style 
FrameAddress 		dw 0h
AlignedFrameAddress dw 0h  

; =====================================================================================================
; CONSTS 

USBLEGSUPoffset 	 = 00h 
USBLEGCTLSTSoffset   = 04h 

; =====================================================================================================
; Debug Strings 

USBLEGSUPmsg 	 db "USBLEGSUP  Register = $"
USBLEGCTLSmsg 	 db "USBLEGCTLS Register = $"

sTakeBIOSControl db "Take EHCI control from BIOS", 13, 10, "$"
sHCResetDone 	 db "HC Reset Done", 13, 10, "$"
sHCInitDone 	 db "HC Init Done", 13, 10, "$"

sDeviceDescriptorMsg  db 13, 10, "Get Device Descriptor ", 13, 10, "$"
sDeviceEnumerationMsg db 13, 10, "Device Enumeration    ", 13, 10, "$"
sHubDescriptorMsg 	  db 13, 10, "Get Hub Descriptor    ", 13, 10, "$"

; =====================================================================================================

 	; Prints information about HC I/O Registers 
	;
	; EBX - contains BAR address | Or Not 
	; FS  - contains Selector For Zero Memory
	processEHCIHC proc near  

		; Include code for Operational Registers Displacement CalCulation 
		
		push ebx           		 	; Save 
		push eax           		 	; 
		push edi                 	;
		push esi				 	;
		;---------------------------;
				
		; Rests HC and Inits Registers
		call performInitialWorkaround
		
		call Wait05s

		; Resets powered ports 
		call updatePORTstate
		call Wait05s
		call updatePORTstateReset

		; Zero Transfer Structures Parameters 
		call initTransferStrucutresParametes
		; GET_DESCRIPTOR (Device)
		call getDeviceDescTransaction
		; Update Max Packet Size 
		call updateEndpointParamInQH
		; Set Device Address
		call setDeviceAddrTransaction
		
		cmp [DDbDeviceClass], 09h
		jnz outProcessEHCIHC
		; GET_DESCRIPTOR (hub)
		call getHubDescTransaction

		;call printQTDStatus
		;DUMP 
		;call printTDArrayDump
		;call printOutBufferDump
		;call printInBufferDump

		; DEBUG 
		;call updateOperRegInfo
		;call printOperRegInfo
		;call printNewLineRM
		;call printPORTSCinfo
		;call updateCapRegInfo
		;call printCapRegInfo
		;call printNewLineRM
		;call retrieveLegacyInterruptsEHCI
		;call printUSBLEGSUPReg

		;call printTDArrayDump
		
		; In Transaction
		;call createQueueHead
		;call createInQTD
		
		;call runAQueueinCMD
		;call Wait05s 
		;call stopAQueueinCMD
		
		;call printQTDStatus
		
		;call printTDArrayDump
		;call printOutBufferDump

		;call testPortFunctions
		;call Wait05s 
		;call updatePORTstateReset
  	  
  	  
  	  outProcessEHCIHC:

  		;------------------------;
  		pop esi 				 ;
		pop edi                  ; 
		pop eax                  ; 
		pop ebx            		 ; Recover  


  		ret                               ; 

	endp

	; (1) Takes Control of HC from BIOS 
	; (2) Resets HC 
	; (3) initializes HC with default values 
	;
	performInitialWorkaround proc near

		push ebx           		 ; Save 
		push eax           		 ; 
		push edi                 ;
		push dx                  ;
		;------------------------;

		; Take Control Of USB HC from BIOS 
		call retrieveLegacyInterruptsEHCI 
		call takeEHCIOwnership	 ;

		; Info message 
		mov ah, 09 				 ;
		lea dx, sTakeBIOSControl ; 
		int 21h                  ;
		
		; Resets HC to Default state
		call performHCReset		 ; 

		; Info message 
		mov ah, 09 				 ;
		lea dx, sHCResetDone	 ;  
		int 21h                  ;

		; Init Host Controler 
		call initializeHC		 ;

		; Info message 
		mov ah, 09 				 ;
		lea dx, sHCInitDone		 ; 
		int 21h                  ;
		
		;------------------------;
		pop dx 					 ;
		pop edi                  ; 
		pop eax                  ; 
		pop ebx            		 ; Recover 

		ret                      ;  

	endp

	; Sets HC Reset bit in USB CMD to one 
	; Waits for HC Reset
	;
	performHCReset proc near

		push ebx           		 ; Save 
		push eax           		 ; 
		push ecx                 ;
		;------------------------;

		xor eax, eax 			 ; 

		mov ebx, HCBaseAddress	 ; Base Address
		mov ax, OperRegOff		 ; Offset to Operational Registers
		add ebx, eax 			 ;

		mov eax, fs:[ebx]		 ; USB CMD 
		or eax, 02h				 ; HC Reset Bit to One
		mov fs:[ebx], eax 		 ; Resets HC 
   		
   		; Waits for Host Controller reset  
   	  
   	  waitHCReset:

   	  	mov eax, fs:[ebx]        ; 
   	  	test eax, 02h            ; Checking if Reset is Done 
   	    
   	    jnz waitHCReset          ;   
   
		;------------------------;
		pop ecx                  ; 
		pop eax                  ; 
		pop ebx            		 ; Recover 

	endp

	; Perform Basic Init Actions 
	; Inits Interrupt Register
	; Inits Periodic Frame Regster 
	; Sets Run/Stop bit in CMD Register to ONE  
	; Inits Config Flag Registers  
	; 
	; 
	initializeHC proc near
		
		push ebx           		 ; Save 
		push eax           		 ; 
		push ecx                 ;
		;------------------------;

		mov ebx, HCBaseAddress   ; Takes Base Address 

		; Inits appropriate interrupts 
		call initInterruptRegister 

		; Alloc Periodic Frame
		;------------------------;
		mov eax, PeriodicFramInMem
		mov ecx, 1024
		mov ebx, 1               ; Set T(ermination) - bit

	  initPeriodicQueue:

	  	mov fs:[eax], ebx        ; Sets 1
	  	add eax, 04h 			 ; 4-byte pointer	
	  	loop initPeriodicQueue   ; 

		mov ebx, HCBaseAddress   
		xor ecx, ecx 
		mov cx, OperRegOff
		add ebx, ecx 
		add ebx, PeriodLBoffset
		mov fs:[ebx], PeriodicFramInMem
		;------------------------;
		
		
		call initAsynchQueue 	 ; Allocate Memory for Asynch Queue 

		call runHCinCMD			 ; Sets Run Bit in USB CMD 
		
		; Init Config Flag Register
		mov eax, 01h 			 ; All PORT for HC 
		sub ebx, PeriodLBoffset  ;
		add ebx, CONFIGoffgset   ;
		mov fs:[ebx], eax 		 ; 

		;------------------------;
		pop ecx                  ; 
		pop eax                  ; 
		pop ebx            		 ; Recover 

		ret 

	endp

	; Retrieves Legacy Support Registers 
	;
	; PCI Address from HCPCIAddress Variable
	retrieveLegacyInterruptsEHCI proc near

		push ebx           		 ; Save 
		push eax           		 ; 
		push edx                 ;
		;------------------------;

		mov eax, HCPCIAddress	 ; PCI Address in eax 

		mov ebx, HCBaseAddress	 ; 
		add ebx, HCCPARAMSoffset ; Points on HCCPARAMS Capacity Register 
		mov edx, fs:[ebx]		 ; HCCPARAMS Register	
		and edx, 0000FFFFh		 ; Zero First Part 
		shr edx, 8				 ; Lonely EECP Value 

		mov EECPvalue, dx		 ; Save EECP Value 

		add eax, edx			 ; OUT command for USBLEGSUPReg
 		add eax, USBLEGSUPoffset ; 
 		mov dx, CONFIG_ADDR		 ; Sets out PORT address
		out dx, eax 			 ; Sends request
		mov dx, CONFIG_DATA		 ; Sets input PORT address
		in  eax, dx				 ; Sets data from PCI device
		mov USBLEGSUPReg, eax 	 ; 

		mov eax, HCPCIAddress	 ; PCI Address in eax 
		xor edx, edx 		     ;
		mov dx, EECPvalue 		 ; EECP value  
		add eax, edx			 ; OUT command for USBLEGSUPReg
 		add eax, USBLEGCTLSTSoffset
 		mov dx, CONFIG_ADDR		 ; Sets out PORT address
		out dx, eax 			 ; Sends request
		mov dx, CONFIG_DATA		 ; Sets input PORT address
		in  eax, dx				 ; Sets data from PCI device
		mov USBLEGCTLSTSReg, eax ; 

		;------------------------;
		pop edx                  ; 
		pop eax                  ; 
		pop ebx            		 ; Recover  

		ret 
	
	endp

	; Sets HC OS ownership bit to one 
	; Waits until HC BIOS ownership bit is zero 
	; 
	; 
	takeEHCIOwnership proc near 
		
		push ebx           		 ; Save 
		push eax           		 ; 
		push edx                 ;
		;------------------------; 		
		
		xor ebx, ebx

		mov eax, HCPCIAddress    ; PCI Address
		mov bx, EECPvalue        ; Offset from PARAMS Register
		add eax, ebx 			 ; 

 		add eax, USBLEGSUPoffset ; 
 		mov dx, CONFIG_ADDR		 ; Sets out PORT address
		out dx, eax 			 ; Sends request
		
		mov dx, CONFIG_DATA		 ; Sets input PORT address
		mov eax, USBLEGSUPReg	 ; Legacy Support Register
		or eax, 01000000h 		 ; Sets OS Owned bit 
		out dx, eax				 ; Sets data to PCI device
		mov USBLEGSUPReg, eax 	 ;

	  	xor ebx, ebx 			 ; 

	  	mov eax, HCPCIAddress	 ; HC PCI Address
	  	mov bx, EECPvalue 		 ; Value of Legacy USB Displacement 
 		add ebx, eax             ; Storage for PCI Address

 		; Waits Until BIOS Owned bit is Zero 

	  waitBIOSOwnZero:
	 
	 	mov eax, ebx 			 ; PCI Address 
		  	
	  	mov dx, CONFIG_ADDR		 ; Sets out PORT address
		out dx, eax 			 ; Sends request
		mov dx, CONFIG_DATA		 ; Sets input PORT address
		in  eax, dx				 ; Gets data from PCI device	

		test eax, 00010000h 	 ;

	  	jnz waitBIOSOwnZero		 

		;------------------------;
		pop edx                  ; 
		pop eax                  ; 
		pop ebx            		 ; Recover  

		ret 
	
	endp

	; Setup USB Interrupt Register
	;
	initInterruptRegister proc near
		
		push ebx           		 ; Save 
		push eax           		 ; 
		push edx                 ;
		;------------------------; 

		xor edx, edx 			 ; 

		mov ebx, HCBaseAddress	 ; Base Address in EBX 

		mov dx, OperRegOff		 ; Offset for Operational Register
		add ebx, edx			 ; 
		add ebx, USBINToffset    ;

		mov eax, fs:[ebx]		 ; Gets Interrupt register 
		or eax, 03Fh			 ; Up interrupt bits for OS owned mode
		mov fs:[ebx], eax 		 ; 

		;------------------------;
		pop edx                  ; 
		pop eax                  ; 
		pop ebx            		 ; Recover  

		ret 

	endp

	; Updates information about HC Ports from PORTSC Registers  
	; 
	updatePORTstate proc 

		push ebx           		 ; Save Registers  
		push eax           		 ; 
		push ecx                 ;
		push edi 				 ; 
		;------------------------;

		mov ebx, HCBaseAddress	 ; Base Address For HC 
		mov edi, ebx 			 ; 
		
		add ebx, HCSPARAMSoffset ; 
		mov ecx, fs:[ebx]		 ; HCPARAMS Register in ecx 
		and ecx, 000Fh 			 ; Set only N_PORTS Value 
		
								 ; CX - contains number of ports 

		xor eax, eax 			 ;
		mov ax, OperRegOff
		add edi, eax  			 ; Pointer to Operational Registers
		add edi, PORTSCoffset 	 ; 
								 ; Counter = N_PORTS
	  loopOnPORTstate:

	  	mov eax, fs:[edi]		 ; PORTSC value  ;
	  	test eax, 02h			 ; Test If Device State is "Changed"
	  	jz testNextPORTstate
	  	
	  	and eax, 0FFFFFFFDh		 ; Zero Change state bit 
		mov fs:[edi], eax 		 ; Apply Changes 

		mov eax, fs:[edi]		 ; 
		test eax, 01h 			 ; Test Connection State 
		jz testNextPORTstate
		
		and eax, 0FFFFFFFBh 	 ; Zero Port Enabled Bit
		mov fs:[edi], eax 		 ; Apply Changes 

		or eax, 100h 			 ; Up Reset (8-bit)
		mov fs:[edi], eax        ; Reset Device
      
      testNextPORTstate:

	  	add edi, 04h             ; 32-bit step 
	  	loop loopOnPORTstate	 ; Loop 

		;------------------------;
		pop edi 				 ;
		pop ecx                  ; 
		pop eax                  ; Recover edi
		pop ebx            		 ; Recover ebx 

		ret 
	
	endp

	; Updates information about HC Ports from PORTSC Registers  
	; 
	updatePORTstateReset proc 

		push ebx           		 ; Save Registers  
		push eax           		 ; 
		push ecx                 ;
		push edi 				 ; 
		;------------------------;

		mov ebx, HCBaseAddress	 ; Base Address For HC 
		mov edi, ebx 			 ; 
		
		add ebx, HCSPARAMSoffset ; 
		mov ecx, fs:[ebx]		 ; HCPARAMS Register in ecx 
		and ecx, 000Fh 			 ; Set only N_PORTS Value 
		
								 ; CX - contains number of ports 

		xor eax, eax 			 ;
		mov ax, OperRegOff
		add edi, eax  			 ; Pointer to Operational Registers
		add edi, PORTSCoffset 	 ; 
								 ; Counter = N_PORTS
	  loopOnPORTstateReset:

	  	mov eax, fs:[edi]		 ; PORTSC value  ;
								 ; Terminating Reset Sequence
		and eax, 0FFFFFEFFh      ; (Fix 8-bit)
		mov fs:[edi], eax 		 ; Apply Changes

	  	add edi, 04h             ; 32-bit step 
	  	loop loopOnPORTstateReset; Loop 

		;------------------------;
		pop edi 				 ;
		pop ecx                  ; 
		pop eax                  ; Recover edi
		pop ebx            		 ; Recover ebx 

		ret 
	
	endp

	; Timer (Should be rewritten)
	;
	proc Wait05s near
    
        push    ES
        push    EAX
        mov     AX,0
        mov     ES,AX
        mov     EAX,[ES:046Ch]
        inc     EAX
	
	@@Wait: cmp EAX,[ES:046Ch]
    
        jae     @@Wait
        pop     EAX
        pop     ES
        ret
	
	endp

	; Performs GET_DESCRIPTOR (Device) transaction 
	; Prints main fields 
	;
	getDeviceDescTransaction proc near 
		
		push esi 				 ;
		push eax 				 ;
		push dx 				 ;  
		;------------------------;

		mov ah, 09h 			 
		lea dx, sDeviceDescriptorMsg
		int 21h 

		; Setup Transaction
		call createQueueHead
		lea esi, GetDeviceDescReq18
		call createSetupQTD
		call runAQueueinCMD
		call Wait05s
		call stopAQueueinCMD
		call printQTDStatus

		; In Transaction
		mov ax, [esi + wLengthOffset] ; Bytes to Transfer
		mov [InBytes], ax 			  ; Update IN Bytes field 
		call createQueueHead
		call createInQTD
		call runAQueueinCMD
		call Wait05s 
		call stopAQueueinCMD
		call printQTDStatus

		; Prints Result 
		mov esi, [LinearWriteBufferAddress]
		call retrieveDeviceDescriptor
		call printDeviceDescriptor

		;------------------------;
		pop dx 					 ; 
		pop eax 				 ; 
		pop esi            		 ; Recover 

		ret 
	
	endp
	
	; Performs SET_ADDRESS (Device) transaction 
	; 
	;
	setDeviceAddrTransaction proc near 
		
		push esi 				 ; 
		push eax 				 ;
		push dx 				 ;
		;------------------------;
		
		mov ah, 09h 			 
		lea dx, sDeviceEnumerationMsg
		int 21h 

		; Increments Device Address
		inc [SetDeviceAddrReq + 2]
		call createQueueHead
		lea esi, SetDeviceAddrReq
		call createSetupQTD
		call runAQueueinCMD
		call Wait05s
		call stopAQueueinCMD
		call printQTDStatus 

		; Get Zero IN Packet
		mov ax, [esi + wLengthOffset] ; Bytes to Transaction via Transaction
		mov [InBytes], ax             ; 
		call createQueueHead
		call createInQTD
		call runAQueueinCMD
		call Wait05s 
		call stopAQueueinCMD
		call printQTDStatus

		xor ax, ax 
		mov ax, word ptr [SetDeviceAddrReq + 2] ; Remember updated Device Address
		mov [ValidDeviceAddress], al  			; Saves Valid Device Address  
		
		;------------------------;
		pop dx 					 ; 
		pop eax 				 ; 
		pop esi            		 ; Recover 

		ret 
	
	endp

	; Performs GET_DESCRIPTOR (HUB) transaction 
	; Prints main fields 
	;
	getHubDescTransaction proc near 
		
		push esi 				 ;
		push eax 				 ;
		push dx 				 ; 
		;------------------------;

		mov ah, 09h 			 
		lea dx, sHubDescriptorMsg
		int 21h 

		; Setup Transaction
		call createQueueHead
		lea esi, GetHubDescReq
		call createSetupQTD
		call runAQueueinCMD
		call Wait05s
		call stopAQueueinCMD
		call printQTDStatus

		; In Transaction
		mov ax, [esi + wLengthOffset] ; Bytes to Transfer
		mov [InBytes], ax 			  ; Update IN Bytes field 
		call createQueueHead
		call createInQTD
		call runAQueueinCMD
		call Wait05s 
		call stopAQueueinCMD
		call printQTDStatus

		; Prints Result 
		mov esi, [LinearWriteBufferAddress]
		call retrieveHubDescriptor
		call printHubDescriptor
		
		;------------------------;
		pop dx 					 ; 
		pop eax 				 ; 
		pop esi            		 ; Recover 

		ret 
	
	endp
	
	; Updates Endpoint Characteristics (Max Packet Size) 
	;
	updateEndpointParamInQH proc near

		push ebx           		 ; Save Registers  
		push eax           		 ; 
		;------------------------;

		mov eax, [QHEndpointParam]
		and eax, 0F800FFFFh		 ; Clear bits [26:16] 

		xor ebx, ebx 			 ;
		mov bl, [DDbMaxPacketSize]; Gets updated Max Packet Length 
		shl ebx, 16 			 ; Shifts MaxPacketSize 

		add eax, ebx 			 ; Update QHEndpoint Characteristics Value
		mov [QHEndpointParam], eax 
	
		;------------------------;
		pop eax                  ; 
		pop ebx            		 ; 

		ret 

	endp

	; Init field which are used in QH and qTDs with default values
	; 
	initTransferStrucutresParametes proc near

		push ebx           		 ; Save Registers  
		;------------------------; 

		xor ebx, ebx 			 ; 

		mov [ValidDeviceAddress], bl 
		mov [ValidEndpoint], bl 
		mov [InBytes], bx 

		;------------------------;
		pop ebx            		 ; 

		ret 

	endp

endm
